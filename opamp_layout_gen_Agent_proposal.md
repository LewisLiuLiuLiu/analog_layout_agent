## 1. 核心问题一：版图技巧知识的组织与应用

为了构建一个能够主动应用专业版图设计知识的智能体（Agent），首要任务是解决如何高效、灵活地组织和利用这些知识。传统的知识工程方法，如构建固定的规则库，虽然执行效率高，但缺乏灵活性和对新知识的适应能力。而完全依赖大语言模型（LLM）的“记忆”则受限于上下文窗口和模型的知识截止日期。因此，本方案提出一种结合**检索增强生成（RAG）**与**技能（Skill）模块**的混合模式，旨在兼顾知识的动态性、广泛性与关键操作的执行效率。该模式的核心思想是将Agent视为一个能够主动“查阅资料”和调用“专家工具”的系统，使其在面对复杂多变的版图设计任务时，既能利用海量的文档知识进行推理，又能依赖高度优化的确定性算法完成核心设计步骤。

### 1.1 知识组织策略：RAG与技能模块的混合模式

#### 1.1.1 采用检索增强生成（RAG）作为核心机制

**检索增强生成（Retrieval-Augmented Generation, RAG）** 被确定为本Agent知识系统的核心架构。RAG通过为LLM外挂一个可动态更新的知识库，有效解决了通用大模型知识陈旧、无法访问私有数据以及产生“幻觉”的三大核心痛点 。在本项目中，大量的版图技巧文档和书籍（处理为Markdown格式）将作为外部知识源。当Agent接收到设计任务时，它不会仅依赖LLM的预训练知识，而是会首先将设计需求（如“为差分对设计一个匹配良好的版图”）作为查询（Query），在向量化的知识库中进行语义检索，召回最相关的知识片段（Chunks）。这些片段可能包含关于差分对布局、共心几何、交叉耦合等具体技巧的描述。随后，LLM会结合这些检索到的、有明确来源的上下文信息，生成最终的版图设计指令或代码。这种方式使得Agent的知识库可以像“外接硬盘”一样，随时挂载、更新和扩展，确保其设计决策始终基于最新、最全面的专业知识，并且每一步决策都有据可查，极大地提升了设计的可靠性和可解释性 。

RAG的工作流程可以分解为两个主要阶段：**知识库准备（Knowledge Ingestion）** 和**检索生成（Retrieval & Generation）** 。
1.  **知识库准备**：这是离线完成的预处理阶段。系统会加载所有的Markdown文档，将其分割成合理大小的文本块（Chunks），然后使用一个专门的**嵌入模型（Embedding Model）** 将每个文本块转换成高维度的数值向量（Vector）。这些向量代表了文本的语义信息，并被存储在一个**向量数据库（Vector Database）** 中 。
2.  **检索生成**：这是在线执行的实时阶段。当Agent需要知识时，它会将用户的查询（例如，设计需求或遇到的问题）也转换成向量。然后，系统使用这个查询向量在向量数据库中进行相似度搜索，找出与查询向量最接近的Top-K个文档向量。这些向量对应的原始文本块就是检索到的相关知识。最后，这些知识片段被作为上下文，连同原始查询一起，构建成一个丰富的Prompt，发送给LLM进行推理和生成 。

这种模式的巨大优势在于，它将LLM的推理能力与一个可动态更新、规模庞大的外部知识库相结合。当您的版图技巧文档有新的补充或更新时，只需重新运行知识库准备流程，而无需重新训练或微调整个LLM，这极大地提高了知识管理的灵活性和成本效益 。

#### 1.1.2 将高频、确定性技巧固化为Agent技能（Skill）模块

尽管RAG提供了极大的灵活性，但对于版图中一些**高频、规则明确且计算密集型的任务**，每次都通过LLM检索和推理来决策，会带来不必要的延迟和不确定性。例如，生成一个满足特定DRC规则的最小尺寸晶体管、计算共心几何结构的精确坐标、或执行一个标准的布线算法等。这些任务可以被抽象为一系列独立的、原子化的“技能”（Skill）。每个技能模块都是一个封装了特定版图设计能力的工具（Tool），它接收标准化的输入（如晶体管参数、位置坐标），并直接输出相应的版图几何图形或操作指令。这些技能模块可以由经验丰富的版图工程师预先定义，并用高效的编程语言（如Python）实现，确保其执行效率和结果的确定性。Agent的规划模块在制定设计策略时，可以直接调用这些技能来完成基础操作，而将LLM的推理能力集中在更高层次的、更具创造性的任务规划上。这种将确定性操作固化为技能的做法，借鉴了AI编程助手中将常用代码片段封装为函数的思路，能够显著提升Agent的整体工作效率和稳定性 。

技能模块可以被视为Agent的“肌肉记忆”或“工具箱”。每个Skill都是一个独立的、可执行的代码单元，封装了特定的版图设计能力。例如：
*   **DRC检查器（DRC Checker Skill）** ：一个直接调用KLayout DRC引擎的模块，能够根据您提供的JSON或Markdown格式的DRC约束文件，对当前版图进行实时或批量的设计规则检查，并返回错误列表。
*   **匹配布局生成器（Matching Layout Generator Skill）** ：一个参数化的模块，输入两个需要匹配的晶体管（如差分对），它能自动应用共心、共指、交叉耦合等匹配技巧，生成满足特定对称性要求的布局。
*   **布线器（Router Skill）** ：一个基于特定算法（如A*或迷宫算法）的布线模块，能够根据网表连接关系和DRC约束，自动完成模块间的信号线和电源线连接。

这些Skill模块可以通过**模型上下文协议（Model Context Protocol, MCP）** 与主Agent进行交互 。MCP为LLM与外部工具（即Skill模块）的交互提供了一个标准化的接口。LLM在规划阶段，如果需要执行DRC检查，它会生成一个符合MCP规范的调用指令（例如，`{"name": "run_drc_check", "input": {"layout": "current_layout.gds", "rules": "drc_rules.json"}}`）。Agent的MCP客户端接收到这个指令后，会调用对应的`DRC Checker Skill`模块执行检查，并将结果返回给LLM，供其进行下一步决策 。这种将确定性任务固化为Skill的方式，不仅提升了执行效率，也保证了关键设计规则的严格遵守。

#### 1.1.3 混合模式的优势：兼顾灵活性与执行效率

采用RAG与技能模块相结合的混合模式，旨在取长补短，为版图设计Agent提供一个既灵活又高效的知识应用框架。RAG机制赋予了Agent强大的学习和适应能力，使其能够处理长尾、非结构化的设计问题，并能随着知识库的更新而不断进化。当遇到新的或不熟悉的电路结构时，Agent可以通过检索相关知识来形成解决方案。与此同时，技能模块为Agent提供了坚实的基础设施，保证了核心、高频操作的效率和可靠性。这种架构类似于一个经验丰富的工程师团队：高级工程师（LLM）负责理解复杂需求、进行宏观规划和解决难题，而初级工程师或自动化工具（技能模块）则负责执行标准化的、重复性的绘图任务。两者协同工作，既能保证设计质量，又能大幅提升设计速度。此外，这种分层解耦的设计也使得系统更易于维护和扩展：新增版图技巧只需更新知识库，而优化核心算法则只需修改或增加相应的技能模块，二者互不干扰。

| 特性 | 检索增强生成 (RAG) | 技能模块 (Skill Modules) | 混合模式 |
| :--- | :--- | :--- | :--- |
| **知识来源** | 外部动态知识库（Markdown文档） | 内部固化代码逻辑 | 内外结合 |
| **灵活性** | 高，能适应新知识和未见过的场景 | 低，仅执行预定义功能 | 高，核心任务高效，新场景可学习 |
| **执行效率** | 相对较低（涉及检索、LLM推理） | 高（直接函数调用） | 高，关键路径由技能模块处理 |
| **可靠性** | 依赖检索质量和LLM理解，存在不确定性 | 高，结果是确定性的 | 高，确定性任务由技能保证 |
| **可维护性** | 易于更新知识库，无需修改代码 | 修改规则需重新编码和部署 | 易于更新知识库，核心技能稳定 |
| **适用场景** | 复杂的、需要推理的规划决策（如整体布局策略、匹配方案选择） | 高频、规则明确的原子操作（如绘制单个元件、执行DRC修复） | 全场景覆盖 |

*Table 1: RAG与技能模块混合模式的特性对比*

### 1.2 RAG知识库的构建与实现

构建一个高质量的RAG知识库是确保Agent能够有效利用版图技巧文档的关键。这个过程涉及从原始文档处理到向量存储和检索的多个技术环节，需要精心设计以保证知识的准确性和可访问性。

#### 1.2.1 Markdown文档的预处理与结构化

原始的版图技巧文档（PDF、Word等）在被处理成Markdown格式后，需要进一步的结构化处理才能被RAG系统有效利用。首先，需要使用文档解析工具（如Apache Tika）从Markdown文件中提取出纯文本信息，并尽可能保留其原有的结构信息，如标题层级、列表、代码块等 。这一步骤至关重要，因为结构信息（例如，一个标题下的所有内容通常属于同一个主题）对于后续的文档切片（Chunking）策略有着决定性的影响。在提取文本后，可能还需要进行一些清洗工作，例如去除多余的空行、统一编码格式、处理特殊字符等，以保证后续处理的一致性和准确性。最终，这些结构化的文本将被送入切片模块，为生成高质量的文本块（Chunks）打下基础。

#### 1.2.2 文档切片（Chunking）策略：基于标题与语义

文档切片是RAG流程中的核心技术挑战之一，其目标是将长篇文档分割成若干个语义完整、大小适中的文本块（Chunks）。切片策略直接影响检索的召回率和LLM生成答案的质量。如果Chunk太大，可能会包含过多不相关的信息，增加LLM处理的负担和成本，并可能稀释关键信息；如果Chunk太小，则可能丢失重要的上下文，导致信息不完整 。本方案建议采用一种**混合切片策略**：
1.  **基于结构的切片**：首先，利用Markdown文档的标题层级（H1, H2, H3等）作为天然的切片边界。通常，一个二级或三级标题及其下的所有内容可以构成一个独立的、主题明确的Chunk。这种方法保证了每个Chunk在主题上的内聚性。
2.  **基于语义的切片**：对于没有明确标题或内容过长的段落，可以采用基于语义的切片方法。例如，使用句子分割器将文本分割成句子，然后通过滑动窗口的方式，将连续的若干个句子组合成一个Chunk。更高级的方法是使用语义模型来判断句子之间的连贯性，在语义发生跳跃的地方进行切分。

通过这种混合策略，可以生成既保持主题完整性又大小适中的Chunks，为后续的嵌入和检索步骤奠定坚实基础。

#### 1.2.3 嵌入（Embedding）与向量数据库存储

每个文本块（Chunk）在被创建后，需要通过一个**嵌入模型（Embedding Model）** 转换成高维度的向量表示。这个向量能够捕捉文本的深层语义信息，使得语义上相似的文本在向量空间中的距离也相近。目前，有许多开源和商业的嵌入模型可供选择，例如HuggingFace上的各种模型或OpenAI的`text-embedding-ada-002`。选择合适的嵌入模型对于RAG系统的性能至关重要。生成的向量随后被存储到专门的**向量数据库（Vector Database）** 中，如Chroma, Pinecone, 或Elasticsearch 。向量数据库的核心功能是支持高效的相似度搜索，即根据查询向量，快速找到数据库中与之最相似（距离最近）的若干个向量。除了向量本身，数据库中还会存储每个向量对应的原始文本块（Chunk）及其元数据（如来源文档、页码等），以便在检索到相关向量后，能够迅速定位并获取原始的上下文信息。

#### 1.2.4 检索器（Retriever）的设计与优化

检索器（Retriever）是RAG系统的“搜索引擎”，其职责是根据用户的查询（Query），从向量数据库中召回最相关的知识片段。一个基础的检索器直接将查询文本也通过嵌入模型转换成向量，然后在向量数据库中进行相似度搜索（如余弦相似度或欧氏距离），返回Top-K个最相似的文本块。然而，在实际应用中，单一的向量检索可能不够鲁棒。因此，可以采用更高级的检索策略来提升召回质量：
1.  **混合检索（Hybrid Search）** ：结合传统的关键词检索（如BM25算法）和向量语义检索。关键词检索对于精确匹配专有名词、型号等非常有效，而向量检索则擅长理解查询的深层意图。通过将两者的结果进行融合（例如，使用RRF算法），可以取长补短，获得更高的召回率和准确率 。
2.  **查询改写（Query Rewriting）** ：用户的原始查询可能比较简短或模糊。可以在检索前，利用LLM对查询进行改写，例如，将其扩展为一个更完整、更具体的问题，或者生成多个相关的查询变体，然后并行执行检索，最后合并结果。
3.  **重排序（Reranking）** ：在初步检索后，可以使用一个更精确但计算成本更高的交叉编码器（Cross-Encoder）模型（如`bge-reranker`）对召回的候选文本块进行重新排序。这个模型会同时接收查询和候选文本块作为输入，直接输出它们之间的相关性分数，从而对Top-K结果进行精细化调整，进一步提升最终提供给LLM的上下文质量 。

### 1.3 技能模块的设计与实现

技能模块是Agent执行确定性任务、保证设计质量的关键。将版图技巧转化为可执行的代码模块，需要系统性的设计和实现方法。

#### 1.3.1 识别可模块化的版图技巧

并非所有的版图技巧都适合被模块化为技能。首先，需要对您提供的技巧文档进行梳理，识别出那些具有**明确输入、输出和固定执行流程**的技巧。这些技巧通常是针对特定电路结构或设计目标的。例如：
*   **电路结构相关的技巧**：差分对的对称布局、电流镜的共质心布局、电容阵列的匹配布局等。
*   **设计规则相关的技巧**：满足特定DRC规则的最小间距布线、特定层间的通孔（Via）放置规则等。
*   **性能优化相关的技巧**：为降低噪声而设计的保护环、为减小寄生电容而进行的布线优化等。
这些技巧的共同点是，它们的应用条件和执行步骤相对固定，可以被清晰地定义和编码。

#### 1.3.2 将技巧转化为可执行的规则或函数

一旦识别出可模块化的技巧，下一步就是将其转化为具体的代码实现。这通常涉及与版图编辑工具的API进行交互。以KLayout为例，可以使用其Python API（pya）来编写技能模块。一个技能模块可以被设计成一个Python函数或一个类，它接收特定的参数（如晶体管的尺寸、位置、方向等），然后调用API来创建相应的版图几何图形。例如，一个`create_common_centroid_pair`函数，其输入可能是两个晶体管的参数和它们之间的间距，输出则是在版图上生成的共心布局的晶体管对。在实现这些模块时，需要充分考虑参数化，使其能够适应不同尺寸和工艺的要求。同时，模块内部应包含必要的DRC检查逻辑，确保生成的版图在模块层面就是合规的。

#### 1.3.3 技能模块与主Agent的集成与调用

技能模块需要被无缝地集成到Agent的整体工作流程中。主Agent的规划模块在分析完网表和设计期望后，会生成一个执行计划。这个计划可能包含一系列对技能模块的调用。例如，规划模块可能会生成一个如下的计划：
1.  调用`parse_netlist`技能，解析JSON网表。
2.  识别出电流镜结构，调用`create_current_mirror`技能，生成电流镜版图。
3.  识别出差分对结构，调用`create_common_centroid_pair`技能，生成差分对版图。
4.  调用`route_signal_nets`技能，完成信号线的布线。
5.  调用`run_drc_check`技能，进行最终的DRC验证。
为了实现这种集成，需要设计一个统一的接口，让主Agent能够方便地发现、调用和管理这些技能模块。这可以通过一个**技能注册表（Skill Registry）** 来实现，所有可用的技能模块都在注册表中进行登记，主Agent通过查询注册表来了解有哪些技能可用以及它们的输入输出格式。这种模块化的设计不仅提高了代码的可维护性和复用性，也使得Agent的能力可以方便地通过添加新的技能模块来扩展。

#### 1.3.4 首批技能模块清单与优先级

为便于工程落地，本项目在早期阶段将优先实现一批围绕“单级差分对运算放大器”场景的核心技能模块。每个技能模块都应具有明确的输入/输出定义，并通过技能注册表对外暴露名称、版本、参数说明和返回结果格式，便于规划模块按需选择和组合调用。

| 技能名称 | 功能概述 | 典型输入 | 典型输出 | 优先级 |
| :--- | :--- | :--- | :--- | :--- |
| `parse_netlist` | 解析 JSON 网表，构建内部电路表示（器件列表 + 连接图 + 结构标签） | 网表 JSON 文件路径或对象 | `Circuit` 对象（含器件、网络、模块标注） | P0 |
| `create_nmos_pcell` / `create_pmos_pcell` | 基于工艺与尺寸参数生成单个 MOS 管的 PCell | 器件类型、W/L、倍数、栅指数量、层映射等 | KLayout/GDS 中的单个器件单元 cell | P0 |
| `create_common_centroid_pair` | 为差分对生成共质心/交叉耦合布局骨架 | 两个 MOS 器件参数、目标指数组合方式、目标对称轴 | 差分对布局 cell（含实例排布和约束锚点） | P0 |
| `create_current_mirror` | 识别并生成电流镜结构的匹配布局 | 参与电流镜的 MOS 列表、目标匹配关系 | 电流镜布局 cell | P1 |
| `route_signal_nets_basic` | 在局部区域内为少量网络进行规则约束下的基础布线 | 网络名称、端点坐标、允许走线层、DRC 规则集 | 完成布线的几何对象集合 | P1 |
| `run_drc_check` | 调用 KLayout DRC 引擎对当前版图进行规则检查 | 版图文件路径 / 当前 cell 句柄、DRC 规则集 | DRC 报告（错误列表及统计） | P0 |
| `export_gds` | 将当前设计导出为 GDSII 文件，供后续仿真/流片使用 | 顶层 cell 名称、输出路径、导出选项 | GDSII 文件 | P0 |
| `evaluate_layout_basic` | 基于几何信息计算面积、基本匹配度和约束指标 | 顶层 cell 或版图对象、关键器件列表 | 面积、质心距离、有效面积比等指标 | P1 |

*说明：优先级按 P0（最先实现）、P1、P2 排列。初期阶段可以只覆盖表中 P0/P1 技能，后续根据真实使用反馈和失败案例逐步扩展 Skill 库。*

## 2. 核心问题二：Agent的模块化架构设计

为了构建一个能够自主完成复杂版图设计任务的智能体，需要一个清晰、健壮且可扩展的架构。本方案借鉴了当前AI Agent领域的主流设计范式，特别是以大型语言模型（LLM）为核心的“规划-执行”循环模型 。该架构将Agent的智能行为分解为感知（Perception）、规划（Planning）、行动（Action）和记忆（Memory）四个核心模块，并通过工具（Tools）与外部环境（如KLayout）进行交互。这种模块化的设计不仅使得Agent的行为逻辑清晰可辨，也便于独立开发、测试和优化各个组件，最终实现一个能够处理复杂输入、制定合理策略并生成高质量版图的自主系统。

### 2.1 整体架构：基于LLM的规划-执行循环

Agent的整体工作流程可以被抽象为一个“**感知-规划-行动-记忆**”的循环。当接收到用户输入（网表、设计期望、DRC约束）后，Agent首先通过感知模块解析这些信息，形成对任务的内部理解。随后，规划模块（通常由LLM驱动）根据任务目标和当前状态，制定一个详细的、分步的执行计划。接着，行动模块按照计划，依次调用各种工具（如版图生成API、DRC检查器）来执行具体操作。每一步操作的结果都会被反馈给Agent，并更新到其记忆模块中，以便进行下一步的规划和决策。这个循环会持续进行，直到任务完成或达到预设的终止条件。这种架构的核心在于将LLM的推理和决策能力（Planning）与外部工具的执行能力（Action）解耦，使得Agent能够处理远超LLM自身能力范围的复杂任务。

#### 2.1.1 感知（Perception）模块：解析输入信息

感知模块是Agent与外部世界交互的入口，负责接收和解析所有输入信息。对于本版图设计Agent，其输入包括：
*   **网表（JSON格式）** ：感知模块需要解析JSON文件，提取出电路的拓扑结构、元器件类型（如MOSFET、电阻、电容）、连接关系以及元器件的参数（如宽长比、倍数等）。这通常需要一个专门的JSON解析器来完成。
*   **设计期望（自然语言或结构化文本）** ：这部分输入描述了设计目标，例如“面积最小化”、“功耗优先”或“差分对匹配度最高”。感知模块需要理解这些目标，并将其转化为可量化的指标或优化方向。
*   **DRC约束（JSON或Markdown格式）** ：设计规则检查（DRC）是版图设计的硬性约束。感知模块需要解析这些规则，并将其转换为内部的数据结构，供后续的行动模块（特别是版图生成和验证工具）使用。
感知模块的输出是一个统一、结构化的内部表示，全面描述了设计任务、目标和约束，为后续的规划模块提供了决策依据。

#### 2.1.2 规划（Planning）模块：制定版图设计策略

规划模块是Agent的“大脑”，负责将高层级的、抽象的设计目标分解为一系列具体、可执行的子任务。这个模块通常由一个强大的LLM（如GPT-4）驱动，并采用先进的规划范式，如**ReAct（Reasoning + Acting）** 或**Plan-and-Execute** 。
*   **ReAct范式**：Agent会交替进行“思考（Reasoning）”和“行动（Acting）”。在每一步，LLM首先分析当前状态，思考下一步应该做什么，然后选择一个工具来执行。执行后，LLM观察工具的返回结果，并基于此进行下一轮思考。这种方式思路清晰，易于调试，但可能陷入循环。
*   **Plan-and-Execute范式**：Agent首先花费时间生成一个完整的、详细的执行计划，然后严格按照计划逐步执行。这种方式对于长周期任务效率更高，但对早期规划的质量要求很高，一旦规划出错可能导致整个任务失败。
在本项目中，可以采用一种混合策略：首先使用Plan-and-Execute范式生成一个宏观的版图设计流程（例如，1. 放置核心差分对；2. 放置电流镜；3. 进行全局布线；4. 进行详细布线；5. 运行DRC检查），然后在执行每个宏观步骤时，采用ReAct范式来处理其中出现的具体问题。规划模块的输出是一个任务列表（TODO list），其中每个任务都是原子性的，可以被行动模块直接执行 。

#### 2.1.3 行动（Action）模块：调用工具执行版图生成

行动模块是Agent的“手脚”，负责执行规划模块制定的计划。它的核心功能是调用一系列预先定义好的工具（Tools）来完成具体的版图设计操作。这些工具可以分为两类：
1.  **版图生成工具**：这是Agent的核心执行引擎。基于您已有的KLayout MCP，可以开发一系列API，用于在KLayout中创建和操作版图。例如，`create_transistor(w, l, x, y)`用于在指定位置创建一个晶体管，`route_net(net_name, points)`用于在两个点之间进行布线。此外，还可以集成GDSFactory等参数化单元（PCell）生成工具，以实现更复杂、可复用的版图结构。
2.  **辅助工具**：包括DRC检查器、版图对比工具（LVS）、性能评估脚本等。这些工具为Agent提供了反馈，使其能够验证自己的设计是否满足约束，并评估设计质量。
行动模块会根据规划模块的指令，将任务转化为对具体工具的API调用，并处理工具的返回结果（例如，成功/失败状态、生成的版图对象、DRC错误报告等），然后将这些结果反馈给规划模块和记忆模块。

#### 2.1.4 记忆（Memory）模块：存储与检索设计经验

记忆模块是Agent实现自我学习和迭代的关键。它负责存储和检索信息，克服LLM本身无状态和上下文长度有限的限制 。记忆模块通常分为短期记忆和长期记忆：
*   **短期记忆（Short-Term Memory）** ：存储当前设计会话中的上下文信息。例如，当前已经放置了哪些器件，完成了哪些连接，以及上一步的执行结果是什么。这通常通过维护一个对话历史或工作区状态来实现，可以直接作为LLM的上下文输入。
*   **长期记忆（Long-Term Memory）** ：存储跨会话的持久化信息，如用户偏好、成功的设计模式、失败案例的教训等。这通常通过向量数据库来实现。例如，当一个设计成功完成后，可以将该设计的网表、设计目标、关键决策点和最终版图等信息作为一个经验案例存入长期记忆。在未来的设计任务中，Agent可以检索相似的历史案例，作为新设计的参考。
通过记忆模块，Agent能够积累经验，避免重复犯错，并在不断的实践中提升自己的设计能力。

### 2.2 输入处理模块

输入处理模块是Agent感知能力的具体实现，它负责将您提供的各种设计文件转换成Agent内部统一的数据结构。

#### 2.2.1 网表（JSON）解析器：提取电路结构与元件信息

网表是电路设计的核心描述文件。您提供的JSON格式网表需要被一个专门的解析器处理。这个解析器的任务是：
*   **元件识别**：遍历网表，识别出所有的电路元件，如MOSFET、BJT、电阻、电容等，并提取它们的实例名、模型名和关键参数（如MOSFET的宽W、长L、倍数M等）。
*   **连接关系提取**：解析网表中的连接信息（通常是节点名），构建出整个电路的**连接图（Connectivity Graph）** 。这个图数据结构对于后续的布局和布线至关重要，它清晰地表明了哪些元件的端口是相互连接的。
*   **模块识别**：通过分析连接图，可以识别出一些常见的电路子结构或模块，例如电流镜、差分对、共源共栅（Cascode）结构等。这有助于Agent在规划阶段采用更高层次的、模块化的布局策略。

解析后的网表信息将被存储在一个结构化的对象中，例如一个Python字典或一个自定义的`Circuit`类，供规划模块和行动模块随时访问。

#### 2.2.2 设计期望解析器：理解并量化设计目标

设计期望（如“面积最小”、“匹配最好”）是Agent优化的目标。然而，这些自然语言描述需要被转换成明确的、可量化的指标。
*   **目标分类**：首先，解析器需要识别出设计期望中提到的所有优化目标。例如，从“设计一个面积最小、匹配最好的低噪声运放”中，可以提取出三个目标：`面积最小化`、`匹配最大化`、`噪声最小化`。
*   **目标量化**：接下来，需要将这些目标与一个具体的**评估函数（Evaluation Function）** 关联起来。
    *   `面积最小化` -> 评估函数可以是版图的总面积（由KLayout API计算得出）。
    *   `匹配最大化` -> 评估函数可以是关键匹配对（如差分对）的**失配（Mismatch）** 指标，这需要结合工艺参数和布局信息进行计算。
    *   `噪声最小化` -> 评估函数可能与敏感节点的寄生电容、电阻或特定区域的噪声耦合有关。
*   **权重分配**：当存在多个设计目标时，还需要解析或预设它们之间的权重。例如，在“面积最小”和“匹配最好”之间，哪个更重要？这些权重将用于后续的综合评估和优化。

通过这种方式，模糊的设计期望被转换成了一系列明确的数学优化问题，Agent可以据此来指导其搜索和决策过程。

#### 2.2.3 DRC约束解析器：构建设计规则检查集

DRC（Design Rule Check）是版图设计的硬性约束，必须严格遵守。您提供的DRC约束文件（JSON或Markdown格式）需要被解析成一个内部规则库。
*   **规则解析**：解析器需要读取DRC文件，并理解每一条规则的语法和语义。例如，一条规则可能描述为“Metal1的最小宽度为0.18微米”或“Poly与Metal1之间的最小间距为0.2微米”。
*   **规则对象化**：将每一条解析出的规则转换为一个**规则对象（Rule Object）** 。这个对象包含了规则的类型（如宽度、间距、覆盖）、涉及的图层（如Metal1, Poly）、以及具体的数值约束。
*   **规则集构建**：将所有规则对象组织成一个**规则集（Rule Set）** 。这个规则集可以被DRC检查器Skill模块直接调用。当Agent需要检查版图时，它只需将这个规则集传递给检查器即可。

一个结构良好的DRC规则集，不仅使得自动化检查成为可能，也为Agent在布局布线时进行**规则驱动（Rule-Driven）** 的决策提供了基础。例如，布线器Skill在走线时，可以实时查询规则集，确保每一步都满足最小间距的要求。

#### 2.2.4 输入输出数据格式与接口示例

为了便于不同模块之间解耦，并让LLM能够稳定地生成和理解数据，本项目对核心输入/输出格式做出约定，并给出若干简化示例。

- **网表 JSON（简化示例）**：

```json
{
  "cells": [
    {
      "name": "opamp_diff_stage",
      "devices": [
        {
          "id": "M1",
          "type": "nmos",
          "model": "nmos_1v8",
          "w": 2e-6,
          "l": 0.18e-6,
          "m": 2,
          "terminals": { "g": "vinp", "d": "outp", "s": "tail", "b": "vss" }
        }
      ],
      "nets": ["vinp", "vinn", "outp", "outn", "tail", "vdd", "vss"]
    }
  ],
  "top": "opamp_diff_stage"
}
```

- **DRC 规则 JSON（简化示例）**：

```json
{
  "tech": "toy_180nm",
  "layers": {
    "poly": 1,
    "metal1": 2,
    "metal2": 3
  },
  "rules": [
    { "id": "M1_MIN_WIDTH", "type": "width", "layer": "metal1", "min": 0.18e-6 },
    { "id": "M1_SPACE", "type": "spacing", "layer": "metal1", "min": 0.2e-6 }
  ]
}
```

- **设计目标 JSON（简化示例）**：

```json
{
  "objectives": [
    { "name": "area_min", "weight": 0.5 },
    { "name": "matching_max", "weight": 0.5 }
  ],
  "constraints": {
    "max_iterations": 5
  }
}
```

- **MCP 工具调用约定（示例）**：

所有工具均通过统一的 JSON 结构调用：

```json
{
  "name": "run_drc_check",
  "input": {
    "layout_path": "work/opamp_diff_stage.gds",
    "drc_rules": "config/drc_rules_toy180.json"
  }
}
```

工具返回值也采用结构化 JSON，至少包含：

```json
{
  "ok": true,
  "error": null,
  "data": {
    "violations": 0,
    "details": []
  }
}
```

这些示例并非最终 Schema，但为后续实现提供了一个清晰的起点，后续可以在保持总体结构不变的前提下逐步细化字段。

### 2.3 版图生成引擎

版图生成引擎是Agent行动能力的核心，它负责将规划模块的抽象指令转化为具体的、可视化的版图。这个引擎主要通过与KLayout的集成来实现。

#### 2.3.1 基于KLayout MCP的API调用

您已经拥有一个测试通过的KLayout MCP，这是构建版图生成引擎的绝佳基础。MCP（模型上下文协议）在这里扮演了关键角色，它标准化了Agent（LLM）与KLayout之间的通信方式 。
*   **MCP服务器（MCP Server）** ：您的KLayout MCP可以被封装成一个MCP服务器。这个服务器暴露了一系列标准化的“工具”（Tools），每个工具对应一个KLayout的API功能。例如，可以有`create_cell`（创建单元）、`place_instance`（放置实例）、`create_path`（创建路径）、`run_drc`（运行DRC）等工具。
*   **MCP客户端（MCP Client）** ：Agent内部集成了一个MCP客户端。当规划模块决定需要执行某个操作时（例如，“在(100, 100)处放置一个宽为2um，长为1um的NMOS管”），它会生成一个符合MCP规范的JSON指令。
*   **指令执行**：MCP客户端接收到这个JSON指令后，会将其翻译成对KLayout API的调用，并执行。执行结果（如成功/失败、生成的图形对象ID、DRC错误报告）再通过MCP客户端返回给Agent的LLM，供其进行下一步决策。

这种基于MCP的架构，实现了Agent与KLayout的**松耦合**。Agent的LLM无需关心KLayout API的具体实现细节，它只需要理解MCP暴露的工具接口即可。这使得整个系统更加模块化、易于维护和扩展 。

#### 2.3.2 集成GDSFactory进行参数化单元设计

虽然直接调用KLayout API可以实现版图绘制，但对于模拟电路中大量重复出现的结构（如晶体管、电阻、电容阵列），使用**参数化单元（Parameterized Cells, PCells）** 或**生成器（Generators）** 是更高效、更灵活的方式。**GDSFactory**是一个基于Python的强大的版图生成框架，它非常适合与KLayout和Agent架构集成。
*   **GDSFactory作为Skill模块**：可以将GDSFactory封装成一个或多个Skill模块。例如，可以创建一个`PCellGeneratorSkill`，它内部使用GDSFactory来定义各种PCell（如`nmos`, `pmos`, `resistor`等）。
*   **参数化调用**：当Agent需要创建一个元件时，它不再调用低级的`create_path`等API，而是调用`PCellGeneratorSkill`，并传递一个参数字典（如`{'w': 2e-6, 'l': 1e-6, 'nf': 2}`）。GDSFactory会根据这些参数自动生成一个完整的、符合DRC的版图单元，并将其导入到KLayout中。
*   **复杂结构生成**：GDSFactory的强大之处在于它可以轻松地组合和变换基本单元，生成更复杂的结构。例如，可以定义一个`diff_pair_generator`，它内部调用`nmos` PCell两次，并应用共心、交叉耦合等变换，自动生成一个匹配的差分对版图。

通过集成GDSFactory，Agent的版图生成能力将从“画图”提升到“组装”，极大地提高了设计效率和版图的质量、一致性。

#### 2.3.3 版图中间表示：采用“严格语法”或GDSII

在Agent的规划和执行过程中，版图需要以一种中间格式在内部传递。这有助于解耦不同模块，并提高系统的灵活性。
*   **“严格语法”（Strict Grammar）** ：这是一种高级的、结构化的文本表示，用于描述版图的拓扑结构和设计意图，同时省略了低级的几何细节。例如，一条指令可能是`place M1 at (0, 0) with orientation R90`，而不是直接生成一个具体的矩形。LLM生成这种严格语法，然后由一个编译器将其转换为对GDSFactory或KLayout API的调用。这种方式对LLM更友好，易于理解和生成。
*   **GDSII**：GDSII是集成电路版图的标准二进制格式。Agent也可以直接生成GDSII文件。然而，直接生成GDSII可能过于底层，不利于LLM理解和操作。更可行的方式是，Agent通过API调用生成版图，然后由工具链自动导出为GDSII格式，供后续的仿真和制造使用。

选择哪种IR取决于Agent的复杂度和设计目标。对于需要高度灵活性和推理能力的Agent，采用类似“严格语法”的文本IR可能更为合适。

### 2.4 多Agent协作的可能性

对于极其复杂的运算放大器版图设计任务，单一Agent可能会面临规划能力不足、处理时间过长等问题。在这种情况下，可以考虑采用多Agent协作的架构，将复杂任务分解给多个具有不同专长的Agent来完成 。

#### 2.4.1 布局Agent与布线Agent的分离

一个直观的分解方式是将版图设计流程中的布局和布线任务分配给不同的专业Agent。
*   **布局Agent（Placement Agent）** ：专注于元器件的放置。它的目标是根据电路的拓扑结构、匹配要求和性能目标，确定每个元器件在芯片上的最佳位置。例如，它会负责将差分对、电流镜等关键模块进行共心或交叉耦合布局，以优化匹配性能。
*   **布线Agent（Routing Agent）** ：专注于连接线的生成。在布局Agent完成元器件放置后，布线Agent会根据网表信息，在遵守DRC规则的前提下，为所有网络生成连接路径。布线Agent可以进一步细分为全局布线Agent（负责规划布线路径，避免拥塞）和详细布线Agent（负责生成具体的金属走线）。
这种分工模式使得每个Agent的职责更加单一和明确，可以针对其特定任务进行深度优化。例如，布局Agent可以集成复杂的匹配算法，而布线Agent可以采用高效的迷宫布线或通道布线算法。

#### 2.4.2 不同功能Agent之间的通信与协调机制

多Agent系统的核心挑战在于如何实现Agent之间的有效通信与协调。可以采用以下几种模式：
*   **中心化协调（Orchestrator-Workers）** ：存在一个中心协调Agent（Orchestrator），它负责接收总任务，将其分解，并分发给不同的工作Agent（Workers）。工作Agent完成任务后将结果返回给协调Agent，由协调Agent进行整合和下一步决策。这种模式结构清晰，易于管理，但协调Agent可能成为瓶颈。
*   **去中心化协作（如CrewAI或AutoGen）** ：Agent之间通过消息传递直接进行通信和协作。例如，布局Agent完成放置后，会向布线Agent广播一条消息，包含所有元器件的位置和连接信息。布线Agent接收到消息后，开始执行布线任务。这种模式更加灵活和健壮，但设计和调试的复杂性也更高。
*   **基于角色的协作（Role-Based）** ：为每个Agent定义明确的角色、目标和工具集。例如，可以定义一个“匹配专家Agent”，一个“DRC专家Agent”等。当主Agent遇到特定问题时，可以咨询相应的专家Agent。CrewAI框架就是基于这种思想设计的 。
在选择多Agent架构时，需要权衡系统的复杂性、通信开销和任务并行度。对于初期版本的Agent，建议先从单一Agent架构开始，待其能力成熟后，再逐步探索多Agent协作的可能性。

### 2.5 MVP 场景定义：单级差分对运放版图自动生成

为了保证项目可以尽快形成闭环验证，本方案将“单级差分对运算放大器版图自动生成”作为第一版最小可行产品（MVP）场景。

- **MVP 输入范围**：
  - 一个仅包含差分对 + 电流镜 + 尾电流源的简化 JSON 网表，工艺固定为选定的 toy/开源 PDK 的子集层。
  - 一份裁剪后的 DRC 规则集，仅覆盖 Poly、Metal1/Metal2、Contact/Via 的基本宽度、间距和覆盖规则。
  - 简单的设计目标配置，例如“面积最小 + 匹配优先”的双目标权重。

- **MVP 输出期望**：
  - 在 KLayout 中生成一个可视化的顶层 cell，包含差分对、电流镜和基本供电/地线布线。
  - 通过裁剪后的 DRC 规则检查（目标为 DRC 错误数为 0）。
  - 给出基础几何评估指标：版图总面积、关键差分对/电流镜的质心距离和有效面积比等。

- **MVP 工作流（端到端）**：
  1.  输入网表、DRC 规则和设计目标；感知模块完成解析并构建内部表示。
  2.  规划模块基于当前任务和 RAG 检索结果，生成宏观版图规划（差分对放置、电流镜放置、供电/地线走线策略等）。
  3.  行动模块依次调用首批技能模块（如 `parse_netlist`、`create_common_centroid_pair`、`create_current_mirror`、`route_signal_nets_basic`、`run_drc_check`、`export_gds`）完成具体绘制与检查。
  4.  评估模块汇总 DRC 结果和几何指标，产生一次性评估报告；不达标时，可在限定次数内触发简单的重新规划与调整。

通过围绕这一具体场景进行设计与实现，可以在较短时间内验证整体架构（RAG + Skill + MCP + 自评估）的可行性，并为后续扩展到更复杂的多级运放和完整 PDK 铺平道路。

## 3. 核心问题三：Agent的自我迭代与进化机制

为了让版图设计Agent能够持续提升其设计质量，必须为其设计一套自我迭代和进化的机制。这种机制的核心思想是建立一个**反馈驱动的闭环系统**，让Agent能够像人类工程师一样，从成功和失败的经验中学习，并将这些经验积累起来，用于指导未来的设计。这不仅仅是简单的参数调优，而是涉及到Prompt策略、知识库内容乃至工具使用方式的系统性优化。通过引入“LLM-as-Judge”的评估模块和结构化的记忆机制，Agent可以实现从被动执行到主动学习和进化的跨越。

### 3.1 反馈驱动的自我优化循环

自我优化的核心是建立一个“**执行-评估-反馈-调整**”的循环。Agent每完成一次版图设计任务，都会进入一个评估阶段，该阶段会生成关于此次设计质量的量化指标和定性分析。这些反馈信息随后被用于调整Agent的内部策略，从而在下一次设计任务中表现得更好。

#### 3.1.1 设计“LLM-as-Judge”评估模块

为了自动化评估过程，可以引入一个独立的“**LLM-as-Judge**”模块。这个模块由一个强大的LLM扮演“资深版图评审专家”的角色。当Agent生成一个版图后，评估模块会接收以下信息作为输入：
*   **原始设计输入**：网表、设计期望、DRC约束。
*   **生成的版图**：以GDSII或其他中间格式表示。
*   **DRC检查结果**：由外部DRC工具生成的错误报告。
*   **性能分析结果**：如通过脚本计算出的版图面积、关键路径的寄生参数、差分对的匹配度指标等。
评估模块的LLM会根据这些信息，从多个维度对版图进行打分和评论。例如，它可以评估：
*   **DRC合规性**：是否存在DRC错误？错误的类型和严重程度如何？
*   **性能达成度**：版图面积是否满足最小化要求？关键器件的匹配是否达到预期？
*   **设计合理性**：布局布线是否符合模拟电路的最佳实践？例如，敏感信号线是否得到了良好的隔离？
评估模块的输出是一个结构化的报告，包含各项指标的分数（如1-5分）和详细的文字评语，指出设计的优点和需要改进的地方 。这种基于LLM的评估方法，相比简单的规则校验，能够提供更接近人类专家水平的、更具洞察力的反馈。

#### 3.1.2 定义量化评估指标（面积、匹配度、DRC错误数）

除了LLM的定性评估，还需要一套客观、可量化的评估指标来精确衡量版图质量。这些指标是反馈循环中“量化评分”的基础，也是判断Agent是否取得进步的关键依据。主要指标包括：
*   **DRC错误数**：这是最核心的硬性指标。最终的版图必须实现零DRC错误。在迭代过程中，DRC错误数的减少是衡量改进的直接标志。
*   **版图面积**：在满足所有约束的前提下，版图面积越小越好。可以定义一个目标面积，并计算实际面积与目标面积的比率作为评分依据。
*   **匹配度指标**：对于差分对、电流镜等需要高度匹配的器件，需要定义具体的匹配度指标。例如，可以计算两个器件在版图上所占区域的质心距离、有效面积比、以及周长比等，并将这些几何参数综合成一个匹配度分数。
*   **寄生参数**：对于高频电路，寄生电容和电阻是关键性能瓶颈。可以通过寄生参数提取工具（PEX）来评估关键节点的寄生效应，并将其作为优化目标。
这些量化指标与LLM的定性评语相结合，构成了一个全面、立体的评估体系，为Agent的自我优化提供了明确的方向。

#### 3.1.3 建立自动化反馈流程

整个反馈流程需要被自动化，以实现高效的自我迭代。其工作流程如下：
1.  **Agent生成版图**：主Agent根据当前任务和策略生成一个版图。
2.  **自动评估**：系统自动调用DRC检查器、性能分析脚本和“LLM-as-Judge”模块，对生成的版图进行评估。
3.  **生成反馈报告**：评估结果被整合成一个结构化的反馈报告，包含量化指标和定性评语。
4.  **触发优化**：如果综合评分未达到预设的目标阈值，系统会自动触发优化流程。
5.  **调整策略**：优化器（Optimizer）模块会根据反馈报告，调整主Agent的内部策略。调整的方式可以包括：
    *   **修改Prompt**：根据LLM Judge指出的问题，动态地修改主Agent的系统提示词（System Prompt），例如，增加“请确保差分对的连线完全对称”这样的约束。
    *   **更新知识库**：将本次设计的成功经验或失败教训（例如，“在XX工艺下，使用共心几何结构可以有效提升匹配度”）作为新的知识条目添加到RAG知识库中。
    *   **调整工具参数**：如果问题出在工具调用上，可以调整工具的默认参数或选择不同的工具。
这个自动化流程确保了Agent能够在无人干预的情况下，持续地进行自我改进，直到达到设计目标或达到最大迭代次数 。

### 3.2 Agent Memory机制的设计

Agent Memory（记忆）机制是实现自我迭代与进化的基石。它为Agent提供了存储、管理和检索信息的能力，使其能够超越单次任务的局限，实现知识的长期积累和复用。根据AI Agent的通用架构模型，记忆系统通常被划分为短期记忆和长期记忆，二者协同工作，共同支持Agent的学习和决策过程 。对于版图设计Agent而言，记忆机制将负责存储从输入的网表、设计约束到最终生成的版图、DRC验证结果，乃至设计过程中应用的技巧和策略等所有相关信息。这些记忆不仅是简单的数据存档，更是Agent进行自我反思、分析成功与失败案例、并提炼出可复用设计模式的宝贵资源。一个设计良好的记忆系统，能够让Agent在面对新的设计任务时，快速检索到相似的历史案例，借鉴成功经验，避免重复犯错，从而显著提升设计效率和成功率。

#### 3.2.1 短期记忆：存储当前设计会话的上下文

短期记忆（Short-term Memory）在Agent的架构中扮演着至关重要的角色，其主要功能是存储和管理当前设计会话的即时上下文信息。这类似于人类在进行一项复杂任务时，大脑中临时存储的、用于指导当前操作的信息。对于版图设计Agent，短期记忆将包含一系列关键信息，例如：当前正在处理的运算放大器网表的具体内容（包括晶体管尺寸、连接关系等）、用户提出的设计期望（如“面积最小化”或“匹配优先”）、必须严格遵守的DRC约束列表、以及在设计过程中由规划模块生成的、待行动模块执行的步骤序列。此外，短期记忆还会动态记录Agent在当前会话中已经执行过的操作及其结果，例如已经完成了哪些模块的布局、布线的进度如何、以及是否遇到了任何DRC冲突。这种动态更新的上下文信息，使得Agent在每一步决策时都能拥有一个连贯的、全局的视角，避免了“一叶障目”的短视行为，确保了整个设计流程的逻辑一致性和目标导向性。短期记忆的存在，使得Agent能够进行多步规划和推理，是实现复杂任务自动化的基础。

#### 3.2.2 长期记忆：积累历史设计经验与知识

长期记忆（Long-term Memory）是Agent实现真正“进化”的关键所在，它负责将短期记忆中的有价值信息转化为可长期保存和复用的知识。与短期记忆的临时性不同，长期记忆构成了Agent的核心知识库，是其设计能力的沉淀。在版图设计Agent的场景中，长期记忆将存储经过归纳和提炼的历史设计经验。具体而言，每当一个设计任务完成后，评估模块会对结果进行分析，判断其优劣。成功的案例，连同其输入条件（网表、设计期望）和最终版图，将被作为“最佳实践”存入长期记忆。失败的案例，特别是那些导致严重DRC错误或性能不达标的尝试，同样会被记录，并附带失败原因的分析，作为“经验教训”。更进一步，Agent可以从大量成功和失败的案例中，通过模式识别和抽象总结，提炼出更高层次的设计原则和技巧，例如“对于差分对管，采用共质心布局可以有效提升匹配度”或“在紧凑布局中，优先布线电源和地线可以减少后续拥塞”。这些被提炼出的知识，可以与RAG知识库中的显性知识相互印证和补充，甚至用于动态更新和优化技能模块，形成一个持续学习和自我完善的正向循环。

#### 3.2.3 记忆的存储、检索与更新策略

为了实现高效的记忆管理，必须设计一套完善的存储、检索与更新策略。这套策略决定了Agent如何利用其记忆来指导当前和未来的设计任务。

| 策略 | 描述 | 实现方式 |
| :--- | :--- | :--- |
| **存储 (Storage)** | 将短期记忆中的有价值信息转化为长期记忆中的结构化知识。 | 1. **信息筛选与提取**：由“记忆提取器”模块分析会话历史，提取关键事实和经验。<br>2. **向量化**：将文本信息通过嵌入模型转换为语义向量。<br>3. **向量存储**：将向量及原始文本、元数据存入向量数据库。<br>4. **关系存储**：将复杂实体关系存入图数据库，构建知识图谱。 |
| **检索 (Retrieval)** | 在需要时，从长期记忆中快速、精准地找到相关信息。 | 1. **基于相似度的检索**：利用向量嵌入技术进行语义相似度搜索，找到历史上最相似的设计案例。<br>2. **基于规则的检索**：根据明确的规则（如关键词、标签）强制检索特定类型的案例。<br>3. **上下文感知检索**：结合当前的短期记忆，优先检索与当前任务阶段相关的经验。 |
| **更新 (Update)** | 动态维护记忆库，保持其准确性、时效性和高效性。 | 1. **增量更新**：每次新任务结束后，将新经验追加到记忆库。<br>2. **去重与合并**：在存储新记忆前，检查并处理与已有记忆的冗余。<br>3. **遗忘机制**：引入“重要性”分数和“最后访问时间”，定期清理低价值记忆，避免记忆库无限膨胀。 |

*Table 2: Agent记忆管理策略*

### 3.3 自我迭代与进化的实现路径

在建立了反馈驱动的优化循环和强大的记忆机制之后，Agent就具备了自我迭代与进化的基础能力。实现路径的核心在于将评估反馈和记忆检索的结果转化为具体的改进行动。这不仅仅是简单的参数调整，而是涉及策略、知识乃至模型层面的深度优化。实现路径将借鉴OpenAI Cookbook中展示的自我进化智能体范例，通过“元提示”（Meta-Prompt）等机制，让Agent能够自主地重写自己的“设计指南”，从而实现从错误中学习和持续改进的目标 。

#### 3.3.1 基于反馈调整Prompt策略

Prompt是引导LLM行为的核心，因此，通过调整Prompt来优化Agent的设计策略是最直接、最有效的自我迭代方式之一。当Agent接收到评估模块的负面反馈时（例如，DRC检查失败或面积过大），它不应仅仅尝试随机修改版图，而应首先反思其设计策略本身是否存在问题。这个过程可以通过一个“**元提示”（Meta-Prompt）Agent**来实现。

具体流程如下：
1.  **接收失败反馈**：Agent完成一次版图设计后，评估模块返回了失败的反馈，例如，“版图存在金属间距DRC违规，且总面积超出目标20%”。
2.  **触发元提示Agent**：主Agent将这个失败反馈，连同其当前的设计Prompt、生成的版图描述以及原始的设计要求，一起发送给一个专门的“元提示Agent”。
3.  **生成改进的Prompt**：元提示Agent的任务是分析失败原因，并生成一个改进后的、更有可能成功的Prompt。它的Prompt模板可能如下：
    ```
    你是一个版图设计专家。你收到了一个版图设计任务，但初次尝试失败了。
    原始的设计要求是：{原始设计要求}
    当前的设计策略（Prompt）是：{当前Prompt}
    根据该策略生成的版图存在以下问题：{失败反馈}
    请分析失败原因，并提供一个改进后的、更详细、更具指导性的设计策略（Prompt），以避免上述问题。
    ```
4.  **更新主Agent的Prompt**：元提示Agent生成的新Prompt将替换主Agent原有的Prompt。主Agent将使用这个新的、经过优化的Prompt来开始下一轮的设计迭代。

这个过程形成了一个“**设计-评估-反思-重写Prompt-再设计**”的闭环。通过不断迭代，Agent的Prompt会变得越来越精细和有效，就像一个新手工程师在导师的指导下不断修正自己的设计方法一样。OpenAI Cookbook中的示例代码清晰地展示了这一流程，其中`metaprompt_agent`负责根据评估反馈来改进主Agent的指令 。

#### 3.3.2 动态更新知识库与技能模块

Agent的自我进化不仅体现在策略（Prompt）的优化上，还应体现在其知识库和技能模块的动态更新上。这是一个更深层次的学习过程，旨在将成功的经验和失败的教训固化为可复用的知识。

*   **知识库（RAG）的动态更新**：
    *   **成功案例入库**：当一个设计迭代成功满足了所有要求，Agent可以将这次成功的设计过程、关键决策和最终版图模式作为一条新的“成功经验”存入长期记忆（RAG知识库）。例如，可以记录“在XX工艺下，采用A布局策略和B布线技巧，成功实现了面积为X且匹配度为Y的运放版图”。
    *   **失败案例与解决方案入库**：对于失败的设计，不仅要记录失败本身，更要记录最终的解决方案。当Agent通过调整Prompt或尝试其他方法最终解决了DRC错误或性能问题后，它应该将“问题-分析-解决方案”这一完整链条作为一条“问题解决经验”存入知识库。这使得Agent在未来遇到类似问题时，可以直接检索到解决方案，而不是从头开始试错。

*   **技能模块（Skills）的动态更新**：
    *   **识别高频模式**：通过分析大量的设计会话，Agent可以识别出那些被反复使用且效果良好的版图技巧。例如，如果发现“共心布局”在绝大多数差分对管设计中都带来了高匹配度，那么这个技巧就可以被固化为一个标准的技能模块。
    *   **生成新技能**：在某些情况下，Agent可能会发现一些全新的、有效的版图设计模式。这些模式可以通过代码生成的方式，被封装成一个新的、可调用的技能函数，并集成到Agent的工具箱中。
    *   **参数化与版本控制**：对于已有的技能模块，可以根据新的经验进行参数优化或功能增强。例如，一个“生成电流源”的技能模块，可以根据历史数据优化其默认的W/L比选择策略。所有技能模块的更新都应遵循版本控制，以确保可追溯性和稳定性。

通过这种方式，Agent的知识库和技能集会随着时间推移而不断丰富和优化，使其设计能力呈螺旋式上升。

#### 3.3.3 实现从失败案例中学习与改进

从失败中学习是进化最快的途径。Agent的自我迭代机制必须能够系统性地利用失败案例来驱动改进。这不仅仅是记录失败，而是要深入分析失败的根本原因，并将其转化为未来成功的垫脚石。

1.  **建立失败案例库**：为每一次未能达到设计目标的尝试建立一个详细的档案。档案内容应包括：
    *   失败的设计版图（或其描述）。
    *   完整的评估报告，明确指出所有问题。
    *   Agent当时采用的Prompt和设计策略。
    *   导致失败的决策点（如果可识别）。

2.  **根本原因分析**：当评估模块报告失败时，Agent不应止步于“知道失败了”，而应尝试分析“为什么失败”。这可以通过一个专门的“分析Agent”来完成。该Agent的任务是：
    *   对比失败的设计与成功的范例（可以从知识库中检索）。
    *   结合DRC/LVS报告，定位具体的设计缺陷。
    *   生成一份自然语言的“失败原因分析报告”，例如，“失败原因分析：本次设计的DRC违规主要集中在金属层M2，原因是布线过于密集，且未遵循‘先布关键信号线’的原则”。

3.  **驱动Prompt和知识库的针对性更新**：
    *   **更新Prompt**：将根本原因分析报告作为输入，传递给元提示Agent，生成更具针对性的改进建议。例如，新的Prompt可能会明确加入“在布线时，优先为差分信号线预留通道，并确保M2层金属间距不小于XX nm”这样的指令。
    *   **更新知识库**：将失败案例及其根本原因和最终解决方案作为一个重要的知识点存入长期记忆。这可以形成一个“避坑指南”，帮助Agent在未来避免犯同样的错误。

通过这种系统化的从失败中学习的方法，Agent的每一次“跌倒”都能转化为一次宝贵的成长机会，从而加速其向专家级版图设计师的进化过程。这种机制确保了Agent不仅能记住“做什么”，更能深刻理解“为什么这么做”以及“为什么不能那么做”。

### 3.4 测试与评估计划

为了保证 Agent 在持续迭代中保持稳定性和可回归性，需要在自我评估机制之外，设计一套面向工程实现的测试与评估计划。

- **单元测试（Skill 级）**：
  - 对每一个 Skill 模块（如 `create_common_centroid_pair`、`run_drc_check`、`export_gds`）编写独立测试用例。
  - 使用固定输入参数和工艺配置，检查输出是否满足预期几何/逻辑约束（器件数量、相对位置、对称性、DRC 报告格式等）。
  - 单元测试不依赖 LLM，仅验证确定性代码逻辑。

- **集成测试（单场景端到端）**：
  - 针对 MVP 场景准备若干标准网表和 DRC 规则集，固定 Prompt 和随机种子，运行完整的“生成—DRC—评估”流程。
  - 记录每次运行的 DRC 错误数、面积、匹配度等关键指标，并与基线版本对比。
  - 集成测试应作为每次重要修改（Skill 逻辑、Prompt、RAG 配置）后的必跑流水线。

- **回归测试与基准用例集**：
  - 随着项目推进，逐步积累一组代表性电路（不同拓扑/规格）的“基准用例集”，作为长期回归测试基线。
  - 每次发布新版本 Agent 时，对基准用例集进行全量测试，识别是否存在性能退化或新引入的 DRC 问题。
  - 将回归测试指标与 3.1 节中的量化评估指标结合，形成版本级的对比报告，支撑决策“是否发布”。

## 4. 实施路线图与关键里程碑

为了系统地构建和验证这个复杂的版图设计Agent，建议采用分阶段、迭代式的开发模式。每个阶段都有明确的目标和可交付成果，确保项目稳步推进，并能在早期发现问题并进行调整。

| 阶段 | 名称 | 主要目标 | 关键任务 | 可交付成果 |
| :--- | :--- | :--- | :--- | :--- |
| **第一阶段** | **基础Agent原型搭建** | 构建一个能够接收输入并调用工具生成简单版图的初步Agent。 | 1. 搭建基于LLM的规划-执行循环核心架构。<br>2. 集成KLayout MCP，实现基础API调用。<br>3. 开发简单的版图生成脚本（如放置单个晶体管）。 | 1. 可运行的Agent原型代码。<br>2. 能够根据简单指令在KLayout中生成图形的演示。 |
| **第二阶段** | **知识库与RAG系统集成** | 使Agent具备从知识库中学习和应用版图技巧的能力。 | 1. 完成技巧文档的预处理、切片和向量化，构建RAG知识库。<br>2. 实现RAG检索器，并将其集成到Agent的规划模块中。<br>3. 开发并集成基础技能模块（如DRC检查器、匹配布局生成器）。 | 1. 完整的RAG知识库系统。<br>2. 能够根据知识库内容生成更优版图的Agent版本。<br>3. 一套可用的基础技能模块库。 |
| **第三阶段** | **自我迭代与进化能力实现** | 为Agent赋予自我评估、反思和优化的能力。 | 1. 设计并实现“LLM-as-Judge”评估模块。<br>2. 开发Agent Memory模块（短期和长期）。<br>3. 构建完整的“生成-评估-反思-优化”闭环。 | 1. 自动化评估系统。<br>2. 具备记忆和自学习能力的Agent。<br>3. 能够展示Agent通过迭代优化提升设计质量的案例。 |
| **第四阶段** | **高级功能与性能优化** | 提升Agent的智能化水平和设计效率，探索更高级的架构。 | 1. 探索并实现多Agent协作模式（如布局Agent与布线Agent）。<br>2. 优化版图生成算法和策略，提升设计质量和速度。<br>3. 进行大规模、多样化的测试，并进行性能调优。 | 1. 支持多Agent协作的Agent系统。<br>2. 经过优化的、更高效的版图生成引擎。<br>3. 详细的性能评估报告和用户使用手册。 |

*Table 3: 运算放大器版图设计Agent实施路线图*

### 4.1 第一阶段：基础Agent原型搭建

#### 4.1.1 完成核心架构的初步实现

本阶段的核心任务是搭建起Agent的基本骨架，即实现一个最小可运行的**规划-执行循环**。这包括定义感知、规划、行动和记忆四个核心模块的接口和基本交互逻辑。规划模块将使用一个基础的LLM（如GPT-3.5-turbo）来驱动，行动模块则通过MCP协议与外部工具进行通信。目标是验证整个架构的可行性，确保Agent能够接收输入、进行简单的推理，并生成一个行动计划。

#### 4.1.2 集成KLayout MCP与基础工具调用

在核心架构搭建完成后，需要将您已有的KLayout MCP集成到Agent的行动模块中。这包括将MCP暴露的功能封装成Agent可以调用的“工具”。初期可以先实现几个最基础的工具，例如`create_rectangle`（在指定图层上创建一个矩形）和`run_drc`（调用KLayout的DRC引擎）。这一步是连接Agent“大脑”与“双手”的关键，确保Agent的决策能够转化为实际的版图操作。

#### 4.1.3 实现简单的版图生成功能

最后，在本阶段的结尾，需要实现一个简单的端到端流程。例如，Agent接收一个只包含一个MOSFET的简化网表，然后能够自主地调用工具，在KLayout中生成该MOSFET的基本版图（如一个有源区矩形和一个栅极矩形）。这个简单的演示将验证从输入到输出的完整链路，为后续阶段的复杂功能开发奠定基础。

### 4.2 第二阶段：知识库与RAG系统集成

#### 4.2.1 完成技巧文档的知识库构建

本阶段的重点是处理您提供的版图技巧文档，并将其构建成一个可用的RAG知识库。这包括对所有Markdown文档进行预处理、结构化、切片、嵌入和向量化存储。需要选择合适的嵌入模型和向量数据库，并设计高效的切片策略，以确保检索的准确性。这是一个数据密集型的任务，需要仔细调试和验证。

#### 4.2.2 实现基于RAG的知识检索与应用

在知识库构建完成后，需要开发RAG检索器，并将其集成到Agent的规划模块中。当Agent在制定版图设计策略时，它应该能够根据当前的上下文（如正在处理的电路模块）自动生成查询，并从知识库中检索相关的技巧。然后，LLM需要学会如何利用这些检索到的知识来优化其决策。例如，当处理差分对时，Agent应能检索到关于共心布局的知识，并将其应用到布局规划中。

#### 4.2.3 开发并集成基础技能模块

本阶段还需要开发一系列基础技能模块，并将其集成到Agent的工具箱中。这些技能模块应基于第一阶段识别的可模块化技巧，例如`create_current_mirror`、`create_common_centroid_pair`等。这些模块的开发需要与版图工程师紧密合作，确保其封装了最佳的设计实践。集成后，Agent的规划模块应能直接调用这些技能来生成高质量的电路子模块。

### 4.3 第三阶段：自我迭代与进化能力实现

#### 4.3.1 设计并实现反馈评估机制

本阶段的核心是为Agent引入自我评估的能力。需要设计并实现“LLM-as-Judge”评估模块，定义一套全面的量化评估指标（面积、DRC错误数、匹配度等），并开发自动化脚本，用于在每次版图生成后自动运行评估流程。评估结果需要以结构化的格式输出，为后续的优化提供依据。

#### 4.3.2 开发Agent Memory模块

在评估机制建立后，需要开发Agent的记忆模块。这包括实现短期记忆（用于存储当前会话的上下文）和长期记忆（用于存储历史经验）。长期记忆的实现需要依赖向量数据库，并设计合理的存储、检索和更新策略。目标是让Agent能够开始积累和复用设计经验。

#### 4.3.3 完成自我优化闭环的构建

最后，需要将评估、记忆和规划模块连接起来，构建一个完整的自我优化闭环。当Agent收到负面评估反馈时，它应该能够利用元提示（Meta-Prompt）机制来调整其设计策略（Prompt），并从失败中学习，更新其长期记忆。完成本阶段后，Agent将具备初步的自我迭代和进化能力。

### 4.4 第四阶段：高级功能与性能优化

#### 4.4.1 探索多Agent协作模式

在Agent的核心能力成熟后，可以开始探索更高级的架构，如多Agent协作。可以尝试将布局（Placement）和布线（Routing）任务分离，由两个独立的Agent来处理，并设计它们之间的通信与协调机制。这将有助于提升Agent处理复杂设计任务的能力和效率。

#### 4.4.2 优化版图生成算法与策略

本阶段还需要对Agent的版图生成算法和策略进行深度优化。这可能包括引入更先进的布局算法（如模拟退火、遗传算法）、优化布线策略以减少寄生效应、以及改进Prompt工程，使Agent能够生成更高质量的版图。

#### 4.4.3 进行大规模测试与性能调优

最后，需要对Agent进行大规模的测试，使用不同类型和复杂度的运算放大器网表来验证其通用性和鲁棒性。根据测试结果，进行性能调优，修复bug，并不断完善其功能。完成本阶段后，Agent将是一个功能完善、性能优良的智能版图设计工具。

### 4.5 风险与开放问题

在实施过程中，仍然存在若干需要重点关注的风险与开放问题：

- **LLM 规划质量与稳定性风险**：
  - 不同模型版本、温度设置和上下文长度都会对规划结果产生影响，可能导致版图质量波动。
  - 需要通过 Prompt 约束、工具使用示例和元提示机制，逐步收敛出稳定的“规划风格”，并通过回归测试监控变化。

- **RAG 质量对整体表现的影响**：
  - 技巧文档的结构化程度、Chunk 策略和向量模型选择都会直接影响检索质量。
  - 若检索结果与当前任务不匹配，可能误导 Agent 做出不合理布局决策，需要通过检索日志与人工抽查不断调优。

- **Skill 与真实 PDK 的耦合与可移植性**：
  - 不同工艺/PDK 的层命名、规则细节差异较大，Skill 实现很容易隐含工艺假设。
  - 初期建议以“toy PDK 或开源 PDK 子集”为目标，后续再抽象出更通用的工艺适配层（例如通过映射表配置层名和规则）。

- **工程集成与性能风险**：
  - Agent 调用 KLayout MCP、向量库和 LLM 模型的链路较长，端到端延迟和资源消耗可能较高。
  - 需要在实现时关注缓存策略（如知识检索缓存、DRC 结果缓存）、并发控制和错误恢复机制。

- **开放问题**：
  - 是否需要支持多语言技巧文档检索（中文/英文混合场景），以及应如何选择/训练适配的嵌入模型。
  - 将来是否需要将 Agent 嵌入到现有的 EDA/仿真流程或 CI 流水线中，例如在版图提交前自动执行一轮 Agent 驱动的 DRC/LVS 预检查。
  - 在更复杂的多级运放和大规模模拟系统上，单一 Agent 架构是否足够，还是需要在第四阶段引入更强的多 Agent 协作模式。