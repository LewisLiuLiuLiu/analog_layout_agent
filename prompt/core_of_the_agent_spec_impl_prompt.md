你现在的角色是：负责 Agent Orchestrator 的主程序开发工程师。

【输入上下文】
- 我会提供《opamp_layout_gen_Agent_proposal.md》全文。
- proposal 的 2.1 节描述了感知-规划-行动-记忆的循环，以及 ReAct / Plan-and-Execute 混合策略，3.1–3.3 描述了自我迭代与进化机制。
- 你的任务是：**写出“Agent 核心逻辑实现”章节的工程规格**，指导如何实现主 Agent。

【输出目标】
形成一章专门描述 Agent 主循环、状态管理、LLM 调用、MCP 调用与 Memory 集成的实现说明，使工程师可以据此实现 Orchestrator。

【输出内容结构要求】
建议结构如下：
1. Agent 主循环设计
   - 说明一次完整任务从“接收输入”到“输出版图与报告”的状态机：
     - 接收输入 → 初始化状态 → 规划 → 执行步骤 → 收集结果 → 评估 →（可能的迭代）→ 结束。
   - 给出状态机图或者文字时序描述。

2. 规划模块实现（Planning）
   - 说明使用 LLM 生成计划的策略：
     - 初始使用 Plan-and-Execute 生成宏观任务列表。
     - 执行每个宏观任务时采用 ReAct 方式与工具交互。
   - 描述规划模块的关键接口：
     - 例如：`plan(circuit, objectives, constraints, history) -> Plan`，`refine_plan(prev_plan, feedback) -> Plan`。
   - 说明 Prompt 结构/模板（从宏观上描述，不需要给最终文案），以及如何注入 RAG 检索结果与历史记忆。

3. 执行模块实现（Action）
   - 描述如何从 Plan 中逐条读取“可执行步骤”，映射到具体 Skill/MCP 工具调用。
   - MCP 集成方式：
     - 工具调用请求结构、响应解析逻辑。
     - 超时、重试、错误恢复策略（例如某 Skill 失败时是回滚还是重规划）。
   - 说明 Action 模块如何把执行结果反馈给规划模块和记忆模块。

4. 记忆模块实现（Memory）
   - 区分短期记忆与长期记忆：
     - 短期：当前会话的状态、已经执行的步骤、工具返回结果。
     - 长期：历史任务摘要、成功/失败案例、元提示更新记录。
   - 描述 Memory 的存储方案（例如短期内存用内存对象，长期用向量库 + 文档存储）。
   - 描述 Memory 的读写接口：
     - 例如：`store_step_result(step, result)`，`retrieve_similar_tasks(circuit_signature) -> List[PastCase]`。

5. 自我迭代与进化机制集成
   - 说明如何在评估模块给出负面反馈时，触发“元提示 Agent”，更新主 Agent 的 Prompt 或策略。
   - 描述“失败案例”的存储与检索接口。

6. 日志与可观测性
   - 说明需要记录哪些信息：规划轨迹、工具调用、错误信息、评估结果。
   - 给出日志结构建议（以便后续调试和数据分析）。

【技术深度要求】
- 要写到“**能指导实现一个主进程/服务**”的程度：
  - 明确主循环的伪代码结构或步骤列表。
  - 明确每个子模块对外暴露的函数接口（参数/返回值语义）。
- LLM 调用部分不必绑定具体厂商，但需要说明：
  - 如何组织 prompt（包含系统提示、用户输入、历史上下文、RAG 结果）。
  - 如何处理 token 限制（例如使用摘要/裁剪策略）。

【与整体项目关联性要求】
- 所有接口与名词要与架构章节、RAG 章节、Skill 章节保持一致。
- 规划/执行的逻辑必须围绕 MVP 流程（单级差分运放版图自动生成），不要提前扩展到更复杂场景。