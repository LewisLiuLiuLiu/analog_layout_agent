"""
Data models for Layout Agent workflow state management
布局代理工作流状态管理的数据模型

All models use Pydantic for validation and serialization.
所有模型使用 Pydantic 进行验证和序列化。
"""

from datetime import datetime
from dataclasses import dataclass, field
from typing import Optional, Any
from pydantic import BaseModel, Field, field_validator


class VerificationConfig(BaseModel):
    """Verification configuration for a step
    步骤的验证配置"""
    type: str  # component_exists, placement_check, routing_check, drc_clean, file_exists / 组件存在、布局检查、路由检查、DRC通过、文件存在
    conditions: list[str] = Field(default_factory=list)


class StepDefinition(BaseModel):
    """
    Step definition - generated by Reasoning Agent, immutable after creation.
    步骤定义 - 由推理代理生成，创建后不可修改。
    
    Each step contains / 每个步骤包含:
    - Identification: step_id, category, description / 标识: 步骤ID、类别、描述
    - Execution: tool, parameters / 执行: 工具、参数
    - Validation: expected_output, verification / 验证: 预期输出、验证配置
    - Dependencies: depends_on / 依赖: 依赖的步骤
    - Routing specific: routing_justification (for routing steps) / 路由特定: 路由理由（用于路由步骤）
    """
    step_id: int
    category: str  # device-creation, placement-layout, routing-connection, verification-drc, export-query / 设备创建、布局放置、路由连接、DRC验证、导出查询
    description: str
    skill: str = ""  # Optional skill name / 可选技能名称
    tool: str
    parameters: dict = Field(default_factory=dict)
    expected_output: dict = Field(default_factory=dict)
    verification: VerificationConfig
    depends_on: list[int] = Field(default_factory=list)
    routing_justification: Optional[str] = None
    max_retries: int = 3


class WorkflowState(BaseModel):
    """
    Workflow state - only 'completed' array and 'updated_at' can be modified.
    工作流状态 - 只有 'completed' 数组和 'updated_at' 可以修改。
    
    Key constraints / 关键约束:
    - completed array can only contain True or False / completed 数组只能包含 True 或 False
    - completed[i] corresponds to steps[i] / completed[i] 对应 steps[i]
    - Only False -> True transition is allowed / 只允许 False -> True 的转换
    """
    design_name: str
    pdk: str
    created_at: datetime = Field(default_factory=datetime.now)
    updated_at: datetime = Field(default_factory=datetime.now)
    steps: list[StepDefinition]
    completed: list[bool]
    
    @field_validator('completed')
    @classmethod
    def validate_completed(cls, v: list) -> list[bool]:
        """Ensure completed array only contains boolean values
        确保 completed 数组只包含布尔值"""
        for i, val in enumerate(v):
            if not isinstance(val, bool):
                raise ValueError(f'completed[{i}] must be bool, got {type(val).__name__}: {val}')
        return v
    
    def model_post_init(self, __context: Any) -> None:
        """Validate that completed array length matches steps array length
        验证 completed 数组长度与 steps 数组长度匹配"""
        if len(self.completed) != len(self.steps):
            raise ValueError(
                f'completed length ({len(self.completed)}) must equal steps length ({len(self.steps)})'
            )
    
    def get_first_incomplete_step(self) -> Optional[int]:
        """Find the index of the first False step
        查找第一个未完成步骤的索引"""
        for i, done in enumerate(self.completed):
            if not done:
                return i
        return None
    
    def get_first_incomplete_step_definition(self) -> Optional[StepDefinition]:
        """Get the first incomplete step definition
        获取第一个未完成的步骤定义"""
        idx = self.get_first_incomplete_step()
        if idx is not None:
            return self.steps[idx]
        return None
    
    def mark_step_complete(self, step_index: int) -> None:
        """
        Mark a step as completed (only False -> True transition allowed)
        将步骤标记为已完成（只允许 False -> True 转换）
        
        Raises / 异常:
            IndexError: If step_index is out of range / 如果步骤索引超出范围
            ValueError: If step is already completed / 如果步骤已完成
        """
        if step_index < 0 or step_index >= len(self.completed):
            raise IndexError(f"Step index {step_index} out of range (0-{len(self.completed)-1})")
        if self.completed[step_index]:
            raise ValueError(f"Step {step_index} is already completed")
        self.completed[step_index] = True
        self.updated_at = datetime.now()
    
    def get_progress_percentage(self) -> float:
        """Get completion percentage"""
        if not self.completed:
            return 0.0
        return (sum(self.completed) / len(self.completed)) * 100
    
    def is_all_completed(self) -> bool:
        """Check if all steps are completed"""
        return all(self.completed)
    
    def get_step_by_id(self, step_id: int) -> Optional[StepDefinition]:
        """Get step definition by step_id"""
        for step in self.steps:
            if step.step_id == step_id:
                return step
        return None


@dataclass
class LayoutWorkflowState:
    """
    State class for pydantic-graph workflow.
    
    This is a mutable dataclass used during workflow execution.
    """
    design_name: str
    pdk: str
    steps: list[dict]
    completed: list[bool]
    current_step_index: int = 0
    retry_count: int = 0
    max_retries: int = 3
    
    @classmethod
    def from_workflow_state(cls, ws: WorkflowState) -> "LayoutWorkflowState":
        """Create LayoutWorkflowState from WorkflowState"""
        first_incomplete = ws.get_first_incomplete_step()
        return cls(
            design_name=ws.design_name,
            pdk=ws.pdk,
            steps=[s.model_dump() for s in ws.steps],
            completed=ws.completed.copy(),
            current_step_index=first_incomplete if first_incomplete is not None else 0
        )
    
    def to_workflow_state(self) -> WorkflowState:
        """Convert back to WorkflowState"""
        return WorkflowState(
            design_name=self.design_name,
            pdk=self.pdk,
            steps=[StepDefinition(**s) for s in self.steps],
            completed=self.completed.copy()
        )
    
    def get_current_step(self) -> Optional[dict]:
        """Get the current step definition"""
        if 0 <= self.current_step_index < len(self.steps):
            return self.steps[self.current_step_index]
        return None
    
    def reset_retry_count(self) -> None:
        """Reset retry count for a new step"""
        self.retry_count = 0


@dataclass
class StepResult:
    """Result of step execution"""
    success: bool
    data: Optional[dict] = None
    message: str = ""
    error: Optional[dict] = None
    
    def to_dict(self) -> dict:
        return {
            "success": self.success,
            "data": self.data,
            "message": self.message,
            "error": self.error
        }


@dataclass
class VerificationResult:
    """Result of step verification"""
    passed: bool
    message: str = ""
    details: Optional[dict] = None
    
    def to_dict(self) -> dict:
        return {
            "passed": self.passed,
            "message": self.message,
            "details": self.details
        }
