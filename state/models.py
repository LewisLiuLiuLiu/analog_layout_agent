"""
Data models for Layout Agent workflow state management
布局代理工作流状态管理的数据模型

All models use Pydantic for validation and serialization.
所有模型使用 Pydantic 进行验证和序列化。
"""

from datetime import datetime
from dataclasses import dataclass, field
from typing import Optional, Any
from pydantic import BaseModel, Field, field_validator


class VerificationConfig(BaseModel):
    """Verification configuration for a step
    步骤的验证配置"""
    type: str  # component_exists, placement_check, routing_check, drc_clean, file_exists / 组件存在、布局检查、路由检查、DRC通过、文件存在
    conditions: list[str] = Field(default_factory=list)


class StepDefinition(BaseModel):
    """
    Step definition - generated by Reasoning Agent, immutable after creation.
    步骤定义 - 由推理代理生成，创建后不可修改。
    
    重构说明：
    - 新增 objective, expected_behavior, context_hints 字段（目标导向模式）
    - 保留 tool, parameters 字段用于向后兼容（过渡期）
    - Act Agent 根据 objective 自主选择工具执行
    """
    step_id: int
    category: str  # device-creation, placement-layout, routing-connection, verification-drc, export-query
    description: str  # 人类可读的描述
    
    # 目标导向字段（新架构）
    objective: str = ""  # 任务目标：描述需要完成什么
    expected_behavior: dict = Field(default_factory=dict)  # 期望结果
    context_hints: dict = Field(default_factory=dict)  # 上下文提示
    
    # 兼容性字段（旧架构，过渡期保留）
    skill: str = ""
    tool: str = ""  # 已废弃：act agent 自主选择
    parameters: dict = Field(default_factory=dict)  # 已废弃
    expected_output: dict = Field(default_factory=dict)  # 映射到 expected_behavior
    
    verification: VerificationConfig
    depends_on: list[int] = Field(default_factory=list)
    routing_justification: Optional[str] = None
    max_retries: int = 3
    
    def get_effective_objective(self) -> str:
        """获取有效的任务目标，兼容新旧格式"""
        if self.objective:
            return self.objective
        # 兼容旧格式：从 description + tool 推断
        if self.tool:
            return f"{self.description} (使用 {self.tool})"
        return self.description
    
    def is_objective_based(self) -> bool:
        """判断是否为目标导向模式（新架构）"""
        return bool(self.objective) and not bool(self.tool)


class WorkflowState(BaseModel):
    """
    Workflow state - only 'completed' array and 'updated_at' can be modified.
    工作流状态 - 只有 'completed' 数组和 'updated_at' 可以修改。
    
    Key constraints / 关键约束:
    - completed array can only contain True or False / completed 数组只能包含 True 或 False
    - completed[i] corresponds to steps[i] / completed[i] 对应 steps[i]
    - Only False -> True transition is allowed / 只允许 False -> True 的转换
    """
    design_name: str
    pdk: str
    created_at: datetime = Field(default_factory=datetime.now)
    updated_at: datetime = Field(default_factory=datetime.now)
    steps: list[StepDefinition]
    completed: list[bool]
    
    @field_validator('completed')
    @classmethod
    def validate_completed(cls, v: list) -> list[bool]:
        """Ensure completed array only contains boolean values
        确保 completed 数组只包含布尔值"""
        for i, val in enumerate(v):
            if not isinstance(val, bool):
                raise ValueError(f'completed[{i}] must be bool, got {type(val).__name__}: {val}')
        return v
    
    def model_post_init(self, __context: Any) -> None:
        """Validate that completed array length matches steps array length
        验证 completed 数组长度与 steps 数组长度匹配"""
        if len(self.completed) != len(self.steps):
            raise ValueError(
                f'completed length ({len(self.completed)}) must equal steps length ({len(self.steps)})'
            )
    
    def get_first_incomplete_step(self) -> Optional[int]:
        """Find the index of the first False step
        查找第一个未完成步骤的索引"""
        for i, done in enumerate(self.completed):
            if not done:
                return i
        return None
    
    def get_first_incomplete_step_definition(self) -> Optional[StepDefinition]:
        """Get the first incomplete step definition
        获取第一个未完成的步骤定义"""
        idx = self.get_first_incomplete_step()
        if idx is not None:
            return self.steps[idx]
        return None
    
    def mark_step_complete(self, step_index: int) -> None:
        """
        Mark a step as completed (only False -> True transition allowed)
        将步骤标记为已完成（只允许 False -> True 转换）
        
        Raises / 异常:
            IndexError: If step_index is out of range / 如果步骤索引超出范围
            ValueError: If step is already completed / 如果步骤已完成
        """
        if step_index < 0 or step_index >= len(self.completed):
            raise IndexError(f"Step index {step_index} out of range (0-{len(self.completed)-1})")
        if self.completed[step_index]:
            raise ValueError(f"Step {step_index} is already completed")
        self.completed[step_index] = True
        self.updated_at = datetime.now()
    
    def get_progress_percentage(self) -> float:
        """Get completion percentage"""
        if not self.completed:
            return 0.0
        return (sum(self.completed) / len(self.completed)) * 100
    
    def is_all_completed(self) -> bool:
        """Check if all steps are completed"""
        return all(self.completed)
    
    def get_step_by_id(self, step_id: int) -> Optional[StepDefinition]:
        """Get step definition by step_id"""
        for step in self.steps:
            if step.step_id == step_id:
                return step
        return None


@dataclass
class LayoutWorkflowState:
    """
    State class for pydantic-graph workflow.
    
    This is a mutable dataclass used during workflow execution.
    """
    design_name: str
    pdk: str
    steps: list[dict]
    completed: list[bool]
    current_step_index: int = 0
    retry_count: int = 0
    max_retries: int = 3
    
    @classmethod
    def from_workflow_state(cls, ws: WorkflowState) -> "LayoutWorkflowState":
        """Create LayoutWorkflowState from WorkflowState"""
        first_incomplete = ws.get_first_incomplete_step()
        return cls(
            design_name=ws.design_name,
            pdk=ws.pdk,
            steps=[s.model_dump() for s in ws.steps],
            completed=ws.completed.copy(),
            current_step_index=first_incomplete if first_incomplete is not None else 0
        )
    
    def to_workflow_state(self) -> WorkflowState:
        """Convert back to WorkflowState"""
        return WorkflowState(
            design_name=self.design_name,
            pdk=self.pdk,
            steps=[StepDefinition(**s) for s in self.steps],
            completed=self.completed.copy()
        )
    
    def get_current_step(self) -> Optional[dict]:
        """Get the current step definition"""
        if 0 <= self.current_step_index < len(self.steps):
            return self.steps[self.current_step_index]
        return None
    
    def reset_retry_count(self) -> None:
        """Reset retry count for a new step"""
        self.retry_count = 0


@dataclass
class StepResult:
    """Result of step execution"""
    success: bool
    data: Optional[dict] = None
    message: str = ""
    error: Optional[dict] = None
    
    def to_dict(self) -> dict:
        return {
            "success": self.success,
            "data": self.data,
            "message": self.message,
            "error": self.error
        }


@dataclass
class VerificationResult:
    """Result of step verification"""
    passed: bool
    message: str = ""
    details: Optional[dict] = None
    
    def to_dict(self) -> dict:
        return {
            "passed": self.passed,
            "message": self.message,
            "details": self.details
        }
