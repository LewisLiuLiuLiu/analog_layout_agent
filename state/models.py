"""
Data models for Layout Agent workflow state management

All models use Pydantic for validation and serialization.
"""

from datetime import datetime
from dataclasses import dataclass, field
from typing import Optional, Any
from pydantic import BaseModel, Field, field_validator


class VerificationConfig(BaseModel):
    """Verification configuration for a step"""
    type: str  # component_exists, placement_check, routing_check, drc_clean, file_exists
    conditions: list[str] = Field(default_factory=list)


class StepDefinition(BaseModel):
    """
    Step definition - generated by Reasoning Agent, immutable after creation.
    
    Each step contains:
    - Identification: step_id, category, description
    - Execution: tool, parameters
    - Validation: expected_output, verification
    - Dependencies: depends_on
    - Routing specific: routing_justification (for routing steps)
    """
    step_id: int
    category: str  # device-creation, placement-layout, routing-connection, verification-drc, export-query
    description: str
    skill: str = ""  # Optional skill name
    tool: str
    parameters: dict = Field(default_factory=dict)
    expected_output: dict = Field(default_factory=dict)
    verification: VerificationConfig
    depends_on: list[int] = Field(default_factory=list)
    routing_justification: Optional[str] = None
    max_retries: int = 3


class WorkflowState(BaseModel):
    """
    Workflow state - only 'completed' array and 'updated_at' can be modified.
    
    Key constraints:
    - completed array can only contain True or False
    - completed[i] corresponds to steps[i]
    - Only False -> True transition is allowed
    """
    design_name: str
    pdk: str
    created_at: datetime = Field(default_factory=datetime.now)
    updated_at: datetime = Field(default_factory=datetime.now)
    steps: list[StepDefinition]
    completed: list[bool]
    
    @field_validator('completed')
    @classmethod
    def validate_completed(cls, v: list) -> list[bool]:
        """Ensure completed array only contains boolean values"""
        for i, val in enumerate(v):
            if not isinstance(val, bool):
                raise ValueError(f'completed[{i}] must be bool, got {type(val).__name__}: {val}')
        return v
    
    def model_post_init(self, __context: Any) -> None:
        """Validate that completed array length matches steps array length"""
        if len(self.completed) != len(self.steps):
            raise ValueError(
                f'completed length ({len(self.completed)}) must equal steps length ({len(self.steps)})'
            )
    
    def get_first_incomplete_step(self) -> Optional[int]:
        """Find the index of the first False step"""
        for i, done in enumerate(self.completed):
            if not done:
                return i
        return None
    
    def get_first_incomplete_step_definition(self) -> Optional[StepDefinition]:
        """Get the first incomplete step definition"""
        idx = self.get_first_incomplete_step()
        if idx is not None:
            return self.steps[idx]
        return None
    
    def mark_step_complete(self, step_index: int) -> None:
        """
        Mark a step as completed (only False -> True transition allowed)
        
        Raises:
            IndexError: If step_index is out of range
            ValueError: If step is already completed
        """
        if step_index < 0 or step_index >= len(self.completed):
            raise IndexError(f"Step index {step_index} out of range (0-{len(self.completed)-1})")
        if self.completed[step_index]:
            raise ValueError(f"Step {step_index} is already completed")
        self.completed[step_index] = True
        self.updated_at = datetime.now()
    
    def get_progress_percentage(self) -> float:
        """Get completion percentage"""
        if not self.completed:
            return 0.0
        return (sum(self.completed) / len(self.completed)) * 100
    
    def is_all_completed(self) -> bool:
        """Check if all steps are completed"""
        return all(self.completed)
    
    def get_step_by_id(self, step_id: int) -> Optional[StepDefinition]:
        """Get step definition by step_id"""
        for step in self.steps:
            if step.step_id == step_id:
                return step
        return None


@dataclass
class LayoutWorkflowState:
    """
    State class for pydantic-graph workflow.
    
    This is a mutable dataclass used during workflow execution.
    """
    design_name: str
    pdk: str
    steps: list[dict]
    completed: list[bool]
    current_step_index: int = 0
    retry_count: int = 0
    max_retries: int = 3
    
    @classmethod
    def from_workflow_state(cls, ws: WorkflowState) -> "LayoutWorkflowState":
        """Create LayoutWorkflowState from WorkflowState"""
        first_incomplete = ws.get_first_incomplete_step()
        return cls(
            design_name=ws.design_name,
            pdk=ws.pdk,
            steps=[s.model_dump() for s in ws.steps],
            completed=ws.completed.copy(),
            current_step_index=first_incomplete if first_incomplete is not None else 0
        )
    
    def to_workflow_state(self) -> WorkflowState:
        """Convert back to WorkflowState"""
        return WorkflowState(
            design_name=self.design_name,
            pdk=self.pdk,
            steps=[StepDefinition(**s) for s in self.steps],
            completed=self.completed.copy()
        )
    
    def get_current_step(self) -> Optional[dict]:
        """Get the current step definition"""
        if 0 <= self.current_step_index < len(self.steps):
            return self.steps[self.current_step_index]
        return None
    
    def reset_retry_count(self) -> None:
        """Reset retry count for a new step"""
        self.retry_count = 0


@dataclass
class StepResult:
    """Result of step execution"""
    success: bool
    data: Optional[dict] = None
    message: str = ""
    error: Optional[dict] = None
    
    def to_dict(self) -> dict:
        return {
            "success": self.success,
            "data": self.data,
            "message": self.message,
            "error": self.error
        }


@dataclass
class VerificationResult:
    """Result of step verification"""
    passed: bool
    message: str = ""
    details: Optional[dict] = None
    
    def to_dict(self) -> dict:
        return {
            "passed": self.passed,
            "message": self.message,
            "details": self.details
        }
